* Homework Problem 2.55
  Ok.
* Homework Problem 2.56
  Ok.
* Homework Problem 2.57
  ~./cs-app/code/data/show-bytes.c~ : [[file:~/Documents/Git/study/cs-app/code/data/show-bytes.c][show_bytes.c]]
#+NAME hp57
#+BEGIN_SRC C
  void show_short(short x) {
    show_bytes((byte_pointer) &x, sizeof(short));
  }

  void show_long(long x) {
    show_bytes((byte_pointer) &x, sizeof(long));
  }

  void show_double(double x) {
    show_bytes((byte_pointer) &x, sizeof(double));
  }

  /* Homework 2.57 */
  printf("Homework 2.57\n");
  show_short(5);
  show_long(5);
  show_double(5.0);
#+END_SRC
* Homework Problem 2.58
#+NAME ex58
#+BEGIN_SRC C
  #include <stdio.h>

  int is_little_endian() {
    unsigned int x = 1;
    return (x & 0xFF) == 1;
  }

  int main() {
    printf("Is little endian? %d\n", is_little_endian());

    return 0;
  }
#+END_SRC

#+RESULTS:
: Is little endian? 1

* Homework Problem 2.59
#+NAME ex59
#+BEGIN_SRC C
  #include <stdio.h>

  int main() {
    printf("x=0x89ABCDEF and y=0x76543210 -> 0x765432EF\n");
    printf("%X\n", (0x89ABCDEF & 0xFF) | (0x76543210 & 0xFFFFFF00));

    return 0;
  }
#+END_SRC

#+RESULTS:
| x=0x89ABCDEF | and | y=0x76543210 | -> | 0x765432EF |
| 765432EF     |     |              |    |            |
* Homework Problem 2.60
#+NAME ex60
#+BEGIN_SRC C
  #include <assert.h>

  unsigned replace_byte(unsigned x, int i, unsigned char b) {
    int pos = (sizeof(int)) * 2 * i;
    int mask = ~(0xFF << pos);
    return (x & mask) | (b << pos);
  }

  int main() {
    assert(replace_byte(0x12345678, 2, 0xAB) == 0x12AB5678);
    assert(replace_byte(0x12345678, 0, 0xAB) == 0x123456AB);

    return 0;
  }

#+END_SRC

#+RESULTS:

* Homework Problem 2.61
#+NAME ex61
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /* produces 1 when any bit in stream is 1 */
  int anyBit1(int x, int i) {
    return (x & 1 << i) > 0;
  }

  /* produces 1 when any bit in stream is 0 */
  int anyBit0(int x, int i) {
    return (x & 1 << i) == 0;
  }

  /* produces 1 when any bit in LSB of stream is 1 */
  int anyBit1InLSB(int x, int i) {
    if (i > (sizeof(int) - 1) << 1) {
      return 0;
    }
    return anyBit1(x, i);
  }

  /* produces 1 when any bit in MSB of stream is 0 */
  int anyBit0InMSB(int x, int i) {
    if (i < (sizeof(int) - 1) << 3) {
      return 0;
    }
    return anyBit0(x, i);
  }

  /* checks each bit of x with the pointer function */
  int checkBitsBy(int (*func)(int, int), int x) {
    int i;
    for (i = 0; i < (sizeof (int)) * 8; i++) {
      if (func(x, i)) {
        return 1;
      }
    }
    return 0;
  }

  void tests() {
    /* anyBit1 */
    assert(checkBitsBy(anyBit1, 5) == 1);
    assert(checkBitsBy(anyBit1, 0) == 0);

    /* anyBit0 */
    assert(checkBitsBy(anyBit0, 0) == 1);
    assert(checkBitsBy(anyBit0, -1) == 0);

    /* anyBit1InLSB */
    assert(checkBitsBy(anyBit1InLSB, 0x000000FF) == 1);
    assert(checkBitsBy(anyBit1InLSB, 0xFFFFFF00) == 0);

    /* anyBit0InMSB */
    assert(checkBitsBy(anyBit0InMSB, 0x00FFFFFF) == 1);
    assert(checkBitsBy(anyBit0InMSB, 0xFF000000) == 0);
  }

  int main() {
    tests();

    /* A */
    printf("%d\n", checkBitsBy(anyBit1, 5));
    printf("%d\n", checkBitsBy(anyBit1, 0));

    /* B */
    printf("%d\n", checkBitsBy(anyBit0, 0));
    printf("%d\n", checkBitsBy(anyBit0, -1));

    /* C */
    printf("%d\n", checkBitsBy(anyBit1InLSB, 0x000000FF));
    printf("%d\n", checkBitsBy(anyBit1InLSB, 0xFFFFFF00));

    /* D */
    printf("%d\n", checkBitsBy(anyBit0InMSB, 0x00FFFFFF));
    printf("%d\n", checkBitsBy(anyBit0InMSB, 0xFF000000));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 |
| 0 |
| 1 |
| 0 |
| 1 |
| 0 |
| 1 |
| 0 |
* Homework Problem 2.62
#+NAME ex62
#+BEGIN_SRC C
  #include <stdio.h>
  #include <limits.h>

  int int_shift_are_arithmetic() {
    return (INT_MIN >> 1) < 0;
  }

  int main() {
    printf("Arithmetic Shift? %d\n", int_shift_are_arithmetic());

    return 0;
  }
#+END_SRC

#+RESULTS:
: Arithmetic Shift? 1
* Homework Problem 2.63
#+NAME ex63
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>
  #include <limits.h>

  /* Perform shift arithmetically */
  unsigned srl(unsigned x, int k) {
    unsigned xsra = (int) x >> k;
    int size = 8 * sizeof(unsigned);

    if ((x & 1 << size - 1) > 0) {
      int i;
      for (i = 1; i <= k; i++) {
        xsra -= 1 << size - i;
      }
    }

    return xsra;
  }

  /* Perform shift logically */
  int sra(int x, int k) {
    int xsrl = (unsigned) x >> k;
    int size = 8 * sizeof(int);

    if ((x & 1 << size - 1) > 0) {
      int i;
      for (i = 1; i <= k; i++) {
        xsrl += 1 << size - i;
      }
    }

    return xsrl;
  }

  void tests() {
    assert(srl(UINT_MAX, 2) == UINT_MAX >> 2);
    assert(sra(INT_MAX, 2) == INT_MAX >> 2);
  }

  int main() {
    tests();

    printf("%u\n", srl(UINT_MAX, 2));
    printf("%d\n", sra(INT_MAX, 2));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1073741823 |
|  536870911 |
* Homework Problem 2.64
#+NAME ex64
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /* Return 1 when any odd bit of x equals 1; 0 otherwise.
     Assume w=32 */
  int any_odd_one(unsigned x) {
    int w = 8 * sizeof(unsigned);

    int i;
    for (i = 0; i < w; i++) {
      if ((x & 1 << w - i - 1) > 0) {
        return 1;
      }
    }

    return 0;
  }

  void tests() {
    assert(any_odd_one(84) == 1);
    assert(any_odd_one(0) == 0);
  }

  int main() {
    tests();

    printf("%d\n", any_odd_one(84));
    printf("%d\n", any_odd_one(0));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 |
| 0 |
* Homework Problem 2.65
#+NAME ex65
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /* Return 1 when x contains an odd number of 1s; 0 otherwise.
     Assume w=32 */
  int odd_ones(unsigned x) {
    int w = 8 * sizeof(unsigned);
    int count = 0;

    int i;
    for (i = 0; i < w; i++) {
      if ((x & 1 << w - i - 1) > 0) {
        count++;
      }
    }

    return (count & 1) == 1;
  }

  void tests() {
    assert(odd_ones(0b10101) == 1);
    assert(odd_ones(0b10001) == 0);
  }

  int main() {
    tests();

    printf("%d\n", odd_ones(0b10101));
    printf("%d\n", odd_ones(0b10001));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 |
| 0 |
* Homework Problem 2.66
#+NAME ex66
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /*
   ,* Generate mask indicating leftmost 1 in x. Assume w=32.
   ,* For example, 0xFF00 -> 0x8000, and 0x6600 -> 0x4000.
   ,* If x = 0, then return 0.
   ,*/
  int leftmost_one(unsigned x) {
    if (x == 0) {
      return 0;
    }

    int w = 8 * sizeof(unsigned);
    int i;
    unsigned mask;
    for (i = w - 1; i > 0; i--) {
      mask = 1 << i;
      if ((x & mask) > 0) {
        return mask;
      }
    }

    return 0;
  }

  void tests() {
    assert(leftmost_one(0) == 0);
    assert(leftmost_one(0xFF00) == 0x8000);
    assert(leftmost_one(0x6600) == 0x4000);
  }

  int main() {
    tests();

    printf("0x%X\n", leftmost_one(0));
    printf("0x%X\n", leftmost_one(0xFF00));
    printf("0x%X\n", leftmost_one(0x6600));

    return 0;
  }
#+END_SRC

#+RESULTS:
|    0x0 |
| 0x8000 |
| 0x4000 |
* Homework Problem 2.67
** A
  Overflow in ~1 << 32~.
** B
  Ok.
** C
  Ok.
** Code
#+NAME ex67
#+BEGIN_SRC C
  #include <stdio.h>

  /* The following code does not run properly on some machines */
  int bad_int_size_is_32() {
    /* Set most significant bit (msb) of 32-bit machine */
    int set_msb = 1 << 31;
    /* Shift past msb of 32-bit word */
    int beyond_msb = 1 << 32;

    /* set_msb is nonzero when word size >= 32
       beyond_msb is zero when word size <= 32 */
    return set_msb && !beyond_msb;
  }

  int int_size_is_32() {
    unsigned set_msb = 1 << 31;
    unsigned beyond_msb = set_msb - ~set_msb - 1;
    return set_msb && !beyond_msb;
  }

  int int_size_is_16() {
    unsigned short set_msb = 1 << 15;
    unsigned short beyond_msb = set_msb - ~set_msb - 1;
    return set_msb && !beyond_msb;
  }

  int main() {
    printf("%d\n", bad_int_size_is_32());
    printf("%d\n", int_size_is_32());
    printf("%d\n", int_size_is_16());

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 |
| 1 |
| 1 |
* Homework Problem 2.68
#+NAME ex68
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /*
   ,* Mask with least signficant n bits set to 1
   ,* Examples: n = 6 --> 0x3F, n = 17 --> 0x1FFFF
   ,* Assume 1 <= n <= w
   ,*/
  int lower_one_mask(int n) {
    int result;
    int i;

    for (i = 0; i < n; i++) {
      result |= 1 << i;
    }

    return result;
  }

  void tests() {
    assert(lower_one_mask(6) == 0x3F);
    assert(lower_one_mask(17) == 0x1FFFF);
  }

  int main() {
    tests();

    printf("0x%X\n", lower_one_mask(6));
    printf("0x%X\n", lower_one_mask(17));

    return 0;
  }
#+END_SRC

#+RESULTS:
|    0x3F |
| 0x1FFFF |
* Homework Problem 2.69
#+NAME ex69
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /*
   ,* Do rotating left shift. Assume 0 <= n < w
   ,* Examples when x = 0x12345678 and w = 32:
   ,*    n=4 -> 0x23456781, n=20 -> 0x67812345
   ,*/
  unsigned rotate_left(unsigned x, int n) {
    unsigned w = 8 * sizeof(unsigned);
    unsigned mask = 1 << w - 1;

    int result = x;
    int bit;
    int i;
    for (i = 0; i < n; i++) {
      bit = (result & mask) >> w - 1;
      result = result << 1 | bit;
    }

    return result;
  }

  void tests() {
    assert(rotate_left(0x12345678, 0) == 0x12345678);
    assert(rotate_left(0x12345678, 4) == 0x23456781);
    assert(rotate_left(0x12345678, 20) == 0x67812345);
  }

  int main() {
    tests();

    printf("0x%X\n", rotate_left(0x12345678, 0));
    printf("0x%X\n", rotate_left(0x12345678, 4));
    printf("0x%X\n", rotate_left(0x12345678, 20));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 0x12345678 |
| 0x23456781 |
| 0x67812345 |
* Homework Problem 2.70
#+NAME ex70
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /*
   ,* Return 1 when x can be represented as an n-bit, 2's-complement
   ,* number; 0 otherwise
   ,* Assume 1 <= n <= w
   ,*/
  int fits_bits(int x, int n) {
    return x < 1 << n;
  }

  void tests() {
    assert(fits_bits(10, 8) == 1);
    assert(fits_bits(256, 8) == 0);
  }

  int main() {
    tests();

    printf("%d\n", fits_bits(10, 8));
    printf("%d\n", fits_bits(256, 8));

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 |
| 0 |
* Homework Problem 2.71
** A
  It does not convert the data to two's complement.
** B
  Ok.
** Code
#+NAME ex71
#+BEGIN_SRC C
  #include <stdio.h>
  #include <assert.h>

  /* Declaration of data type where 4 bytes are packed into an unsigned */
  typedef unsigned packed_t;

  /* Extract byte from word. Return as signed integer */
  int xbyte(packed_t word, int bytenum);

  /* Failed attempt at xbyte */
  /* int xbyte(packed_t word, int bytenum) { */
  /*   return (word >> (bytenum << 3)) & 0xFF; */
  /* } */

  int xbyte(packed_t word, int bytenum) {
    return ((word << (3 - bytenum << 3)) >> (3 << 3)) - 128;
  }

  void tests() {
    packed_t pkg = (unsigned) (128 - 128 << (3 << 3)) +
      (128 - 50 << (2 << 3)) +
      (128 + 127 << (1 << 3)) +
      (128 - 1 << (0 << 3));

    assert(xbyte(pkg, 0) == -1);
    assert(xbyte(pkg, 1) == 127);
    assert(xbyte(pkg, 2) == -50);
    assert(xbyte(pkg, 3) == -128);
  }

  int main() {
    tests();

    packed_t pkg = (unsigned) (128 - 128 << (3 << 3)) +
      (128 - 50 << (2 << 3)) +
      (128 + 127 << (1 << 3)) +
      (128 - 1 << (0 << 3));
    printf("%d\n", xbyte(pkg, 0));
    printf("%d\n", xbyte(pkg, 1));
    printf("%d\n", xbyte(pkg, 2));
    printf("%d\n", xbyte(pkg, 3));

    return 0;
  }
#+END_SRC

#+RESULTS:
|   -1 |
|  127 |
|  -50 |
| -128 |
* Homework Problem 2.72
** A
  The expression is encoded as unsigned (always positive), because the sizeof operator returns an unsigned type.
** B
  Ok.
** Code
#+NAME ex72
#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>

  /* Copy integer into buffer if space is available */
  /* WARNING: The following code is buggy */
  /* FIXED */
  void copy_int(int val, void *buf, int maxbytes) {
    int bytes = maxbytes - sizeof(val);
    if (bytes >= 0) {
      memcpy(buf, (void *) &val, sizeof(val));
    }
  }

  int main() {
    int in = -2;
    int result;
    short noresult = 5;

    copy_int(in, &result, 4);
    printf("%d\n", in);
    printf("%d\n", result);

    copy_int(in, &noresult, 2);
    printf("%d\n", in);
    printf("%d\n", noresult);

    return 0;
  }
#+END_SRC

#+RESULTS:
| -2 |
| -2 |
| -2 |
|  5 |
* Homework Problem 2.73
#+NAME ex73
#+BEGIN_SRC C
  #include <stdio.h>
  #include <limits.h>
  #include <assert.h>

  /* Addition that saturates to TMin or TMax */
  int saturating_add(int x, int y) {
    int result = x + y;
    if (x > 0 && y > 0 && result <= 0) {
      return INT_MAX;
    } else if (x < 0 && y < 0 && result >= 0) {
      return INT_MIN;
    }
    return result;
  }

  void tests() {
    assert(saturating_add(INT_MAX, 1) == INT_MAX);
    assert(saturating_add(INT_MIN, -1) == INT_MIN);
    assert(saturating_add(1, 1) == 2);
  }

  int main() {
    tests();

    printf("%d\n", saturating_add(INT_MAX, 1));
    printf("%d\n", saturating_add(INT_MIN, -1));
    printf("%d\n", saturating_add(1, 1));

    return 0;
  }
#+END_SRC

#+RESULTS:
|  2147483647 |
| -2147483648 |
|           2 |
