* Practice Problem 3.1
  | Operand        | Value |
  |----------------+-------|
  | %rax           | 0x100 |
  | 0x104          |  0xAB |
  | $0x108         |  0x13 |
  | (%rax)         |  0xFF |
  | 4(%rax)        |  0xAB |
  | 9(%rax,%rdx)   |  0x11 |
  | 260(%rcx,%rdx) |  0x13 |
  | 0xFC(,%rcx,4)  |  0xFF |
  | (%rax,%rdx,4)  |  0x11 |
* Practice Problem 3.2
  movl %eax, (%rsp)
  movw (%rax), %dx
  movb $0xFF, %bl
  movb (%rsp,%rdx,4), %dl
  movq (%rdx), %rax
  movb %dx, (%rax)
* Practice Problem 3.3
  movb $0xF, (%ebx)   : incorrect memory value (4 bits).
  movl %rax, (%rsp)   : rax register is a quad word.
  movw (%rax),4(%rsp) : invalid operand form.
  movb %al,%sl        : sl register doesn't exist.
  movq %rax,$0x123    : incorrect memory value (12 bits).
  movl %eax,%rdx      : rdx register is a quad word.
  movb %si, 8(%rbp)   : si register is a word.
* Practice Problem 3.4
  ~src_t *sp;  // rdi~
  ~dest_t *dp; // rsi~
  ~*dp = (dest_t) *sp;~
  Registers: %rax, %eax, %ax, or %al

  | src_t          | dest_t         | Instruction         |
  |---------------+---------------+---------------------|
  | long          | long          | movq (%rdi), %rax   |
  |               |               | movq %rax, (%rsi)   |
  | char          | int           | movsbl (%rdi), %eax |
  |               |               | movl %eax, (%rsi)   |
  | char          | unsigned      | movl (%rdi), %eax   |
  |               |               | movl %eax, (%rsi)   |
  | unsigned char | long          | movq (%rdi), %rax   |
  |               |               | movq %rax, (%rsi)   |
  | int           | char          | movb (%rdi), %al    |
  |               |               | movb %al, (%rsi)    |
  | unsigned      | unsigned char | movb (%rdi), %al    |
  |               |               | movb %al, (%rsi)    |
  | char          | short         | movsbw (%rdi), %ax  |
  |               |               | movw %ax, (%rsi)    |
* Practice Problem 3.5
#+NAME ex5
#+BEGIN_SRC C
  #include <stdio.h>

  void decode1(long *xp, long *yp, long *zp);

  void decode1(long *xp, long *yp, long *zp) {
    long a = *xp;
    long b = *yp;
    long c = *zp;
    ,*yp = a;
    ,*zp = b;
    ,*xp = c;
  }

  int main() {
    long a = 1;
    long b = 2;
    long c = 3;

    printf("%d %d %d\n", a, b, c);
    decode1(&a, &b, &c);
    printf("%d %d %d\n", a, b, c);

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
| 3 | 1 | 2 |
* Practice Problem 3.6
  rax = x
  rcx = y

  | Instruction                 | Result |
  |-----------------------------+--------|
  | leaq 6(%rax), %rdx          | 6+x    |
  | leaq (%rax, %rcx), %rdx     | x+y    |
  | leaq (%rax, %rcx, 4), %rdx  | x+4y   |
  | leaq 7(%rax, %rax, 8), %rdx | 7+9x   |
  | leaq 0xA(, %rcx, 4), %rdx   | 10+4y  |
  | leaq 9(%rax, %rcx, 2), %rdx | 9+x+2y |
* Practice Problem 3.7
  x+4x -> 5x
  5x+2y
  5x+2y+8z

#+NAME ex7
#+BEGIN_SRC C
  long scale2(long x, long y, long z) {
    long t = (5 * x) + (2 * y) + (8 * z);
    return t;
  }
#+END_SRC
* Practice Problem 3.8
  | Instruction                | Destination | Value |
  |----------------------------+-------------+-------|
  | addq %rcx, (%rax)          |       0x100 | 0x100 |
  | subq %rdx, 8(%rax)         |       0x108 |  0xA8 |
  | imulq $16, (%rax, %rdx, 8) |       0x118 |  0xB0 |
  | incq 16(%rax)              |       0x110 |  0x14 |
  | decq %rcx                  |        %rcx |   0x0 |
  | subq %rdx, %rax            |        %rax |  0xFD |
* Practice Problem 3.9
  long shift_left4_rightn(long x, long n)
  x in %rdi, n in %rsi
shift_left4_rightn:
  movq %rdi, %rax   Get x
  salq $4, %rax     x <<= 4
  movl %esi, %ecx   Get n (4 bytes)
  sarq %ecx, %rax   x >>= n
* Practice Problem 3.10
#+NAME ex10
#+BEGIN_SRC C
  long arith2(long x, long y, long z) {
    long t1 = x | y;
    long t2 = 3 >> t1;
    long t3 = ~t2;
    long t4 = z - t3;
    return t4;
  }
#+END_SRC
* Practice Problem 3.11
~xorq %rdx, %rdx~
** A
  It's a optimization of compiler, in which it always results in zero.
  & e ~.
** B
  movq $0, %rdx
** C
  Both use the same amount.
* Practice Problem 3.12
  void uremdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp)
  x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
uremdiv:
  movq  %rdx, %r8
  movq  %rdi, %rax
  divq %rsi
  movq  %rax, (%r8)
  movq  %rdx, (%rcx)
  ret
* Practice Problem 3.13
  A -> setl  (SF ^ OF)
  B -> setge ~(SF ^ OF)
  C -> setbe (CF | ZF)
  D -> setne ~ZF

  C and D.
* Practice Problem 3.14
  A -> setge ~(SF ^ OF)
  B -> sete  ZF
  C -> seta  (~CF ^ ~ZF)
  D -> setle (SF ^ OF) | ZF

  A and C.
