* Practice Problem 3.1
  | Operand        | Value |
  |----------------+-------|
  | %rax           | 0x100 |
  | 0x104          |  0xAB |
  | $0x108         |  0x13 |
  | (%rax)         |  0xFF |
  | 4(%rax)        |  0xAB |
  | 9(%rax,%rdx)   |  0x11 |
  | 260(%rcx,%rdx) |  0x13 |
  | 0xFC(,%rcx,4)  |  0xFF |
  | (%rax,%rdx,4)  |  0x11 |
* Practice Problem 3.2
  movl %eax, (%rsp)
  movw (%rax), %dx
  movb $0xFF, %bl
  movb (%rsp,%rdx,4), %dl
  movq (%rdx), %rax
  movb %dx, (%rax)
* Practice Problem 3.3
  movb $0xF, (%ebx)   : incorrect memory value (4 bits).
  movl %rax, (%rsp)   : rax register is a quad word.
  movw (%rax),4(%rsp) : invalid operand form.
  movb %al,%sl        : sl register doesn't exist.
  movq %rax,$0x123    : incorrect memory value (12 bits).
  movl %eax,%rdx      : rdx register is a quad word.
  movb %si, 8(%rbp)   : si register is a word.
* Practice Problem 3.4
  ~src_t *sp;  // rdi~
  ~dest_t *dp; // rsi~
  ~*dp = (dest_t) *sp;~
  Registers: %rax, %eax, %ax, or %al

  | src_t          | dest_t         | Instruction         |
  |---------------+---------------+---------------------|
  | long          | long          | movq (%rdi), %rax   |
  |               |               | movq %rax, (%rsi)   |
  | char          | int           | movsbl (%rdi), %eax |
  |               |               | movl %eax, (%rsi)   |
  | char          | unsigned      | movl (%rdi), %eax   |
  |               |               | movl %eax, (%rsi)   |
  | unsigned char | long          | movq (%rdi), %rax   |
  |               |               | movq %rax, (%rsi)   |
  | int           | char          | movb (%rdi), %al    |
  |               |               | movb %al, (%rsi)    |
  | unsigned      | unsigned char | movb (%rdi), %al    |
  |               |               | movb %al, (%rsi)    |
  | char          | short         | movsbw (%rdi), %ax  |
  |               |               | movw %ax, (%rsi)    |
* Practice Problem 3.5
#+NAME ex5
#+BEGIN_SRC C
  #include <stdio.h>

  void decode1(long *xp, long *yp, long *zp);

  void decode1(long *xp, long *yp, long *zp) {
    long a = *xp;
    long b = *yp;
    long c = *zp;
    ,*yp = a;
    ,*zp = b;
    ,*xp = c;
  }

  int main() {
    long a = 1;
    long b = 2;
    long c = 3;

    printf("%d %d %d\n", a, b, c);
    decode1(&a, &b, &c);
    printf("%d %d %d\n", a, b, c);

    return 0;
  }
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |
| 3 | 1 | 2 |
* Practice Problem 3.6
  rax = x
  rcx = y

  | Instruction                 | Result |
  |-----------------------------+--------|
  | leaq 6(%rax), %rdx          | 6+x    |
  | leaq (%rax, %rcx), %rdx     | x+y    |
  | leaq (%rax, %rcx, 4), %rdx  | x+4y   |
  | leaq 7(%rax, %rax, 8), %rdx | 7+9x   |
  | leaq 0xA(, %rcx, 4), %rdx   | 10+4y  |
  | leaq 9(%rax, %rcx, 2), %rdx | 9+x+2y |
* Practice Problem 3.7
  x+4x -> 5x
  5x+2y
  5x+2y+8z

#+NAME ex7
#+BEGIN_SRC C
  long scale2(long x, long y, long z) {
    long t = (5 * x) + (2 * y) + (8 * z);
    return t;
  }
#+END_SRC
* Practice Problem 3.8
  | Instruction                | Destination | Value |
  |----------------------------+-------------+-------|
  | addq %rcx, (%rax)          |       0x100 | 0x100 |
  | subq %rdx, 8(%rax)         |       0x108 |  0xA8 |
  | imulq $16, (%rax, %rdx, 8) |       0x118 |  0xB0 |
  | incq 16(%rax)              |       0x110 |  0x14 |
  | decq %rcx                  |        %rcx |   0x0 |
  | subq %rdx, %rax            |        %rax |  0xFD |
* Practice Problem 3.9
  long shift_left4_rightn(long x, long n)
  x in %rdi, n in %rsi
shift_left4_rightn:
  movq %rdi, %rax   Get x
  salq $4, %rax     x <<= 4
  movl %esi, %ecx   Get n (4 bytes)
  sarq %ecx, %rax   x >>= n
* Practice Problem 3.10
#+NAME ex10
#+BEGIN_SRC C
  long arith2(long x, long y, long z) {
    long t1 = x | y;
    long t2 = 3 >> t1;
    long t3 = ~t2;
    long t4 = z - t3;
    return t4;
  }
#+END_SRC
* Practice Problem 3.11
~xorq %rdx, %rdx~
** A
  It's a optimization of compiler, in which it always results in zero.
  & e ~.
** B
  movq $0, %rdx
** C
  Both use the same amount.
* Practice Problem 3.12
  void uremdiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp)
  x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
uremdiv:
  movq  %rdx, %r8
  movq  %rdi, %rax
  divq %rsi
  movq  %rax, (%r8)
  movq  %rdx, (%rcx)
  ret
* Practice Problem 3.13
  A -> setl  (SF ^ OF)
  B -> setge ~(SF ^ OF)
  C -> setbe (CF | ZF)
  D -> setne ~ZF

  C and D.
* Practice Problem 3.14
  A -> setge ~(SF ^ OF)
  B -> sete  ZF
  C -> seta  (~CF ^ ~ZF)
  D -> setle (SF ^ OF) | ZF

  A and C.
* Practice Problem 3.15
  A. je 4003fc
  B. je 400431
  C. 400540
     400547
  D. jmpq 4005ed
* Practice Problem 3.16
** A
#+NAME ex36
#+BEGIN_SRC C
  void cond(long a,  long *p) {
    if (*p & *p) {
      goto l1;
    }
    if (a >= *p) {
      goto l1;
    }
    a = *p;
  l1: return;
  }
#+END_SRC
** B
  Each conditional has a branch because there are different tests.
* Practice Problem 3.17
** A
#+NAME ex37
#+BEGIN_SRC C
  long lt_cnt = 0;
  long ge_cnt = 0;

  long gotodiff_se(long x,  long y) {
    long result;
    if (x >= y) {
      goto x_ge_y;
    }
    goto x_lt_y;
  x_ge_y:
    ge_cnt++;
    result = x - y;
    return result;
  x_lt_y:
    lt_cnt++;
    result =  y - x;
    return result;
  }
#+END_SRC
** B
  Code optimization, when multiple branches.
* Practice Problem 3.18
#+NAME ex18
#+BEGIN_SRC C
  long test(long x, long y, long z) {
    long val = x * y;
    if (x >= -3) {
      if (x <= 2) {
        val = z + (x + y);
      } else {
        val = x * z;
      }
    } else if (y >= x) {
      val = y * z;
    }
    return val;
  }
#+END_SRC
* Practice Problem 3.19
** A
  T_mp = 2(31-16)
  T_mp = 30
** B
  Between 16 and 46 cycles.
* Practice Problem 3.20
** A
  OP -> mod
** B
  res = 7 + x
  if x >= 0
    res = x
  res = res >> 3
  return res
* Practice Problem 3.21
#+NAME ex21
#+BEGIN_SRC C
  long test(long x, long y) {
    long val = y - x;
    if (y <= 0) {
      if (y <= -2) {
        val = x + y;
      } else {
        val = 8 * x;
      }
    } else if (y >= x) {
      val = x + y;
    }
    return val;
  }
#+END_SRC
* Practice Problem 3.22
** A
  n = 4294967296.
** B
  n = 18446744073709551616.
* Practice Problem 3.23
** A
  x = rdi.
  y = rcx.
  n = rdx.
** B
  In the leaq instruction.
** C
#+NAME ex23
#+BEGIN_SRC C
  long dw_loop(long x) {
    int result = x;
    int y = x * x;
    int n = 2 * x;
  loop:
    result += 1 + y;
    n--;
    if (n > 0) {
      goto loop;
    }
    return result;
  }
#+END_SRC
* Practice Problem 3.24
#+NAME ex24
#+BEGIN_SRC C
  long loop_while (long a, long b) {
    long result = 1;
    while (a < b) {
      result *= a + b;
      a =  a + 1;
    }
  }
#+END_SRC
* Practice Problem 3.25
#+NAME ex25
#+BEGIN_SRC C
  long loop_while2(long a, long b) {
    long result = b;
    while (b > 0) {
      result *= a;
      b = b - a;
    }
    return result;
  }
#+END_SRC
* Practice Problem 3.26
** A
  Jump-to-middle translation method.
** B
#+NAME ex26
#+BEGIN_SRC C
  #include <stdio.h>

  long fun_a(unsigned long x) {
    long val = 0;
    while (x != 0) {
      val ^= x;
      x >>= 1;
    }
    return val & 1;
  }

  int main() {
    for (int i = 0; i < 30; ++i) {
      printf("%d\n", fun_a(i));
    }

    return 0;
  }
#+END_SRC

#+RESULTS:
| 0 |
| 1 |
| 1 |
| 0 |
| 1 |
| 0 |
| 0 |
| 1 |
| 1 |
| 0 |
| 0 |
| 1 |
| 0 |
| 1 |
| 1 |
| 0 |
| 1 |
| 0 |
| 0 |
| 1 |
| 0 |
| 1 |
| 1 |
| 0 |
| 0 |
| 1 |
| 1 |
| 0 |
| 1 |
| 0 |
** C
  Thue-Morse sequence.
